## Учебное пособие по LogsQL

Если вы ещё не знакомы с VictoriaLogs, начните с раздела **`ключевых понятий`**.

Затем ознакомьтесь со следующими документами:

- `Как запустить VictoriaLogs`.
- `Как загружать данные в VictoriaLogs`.
- `Как выполнять запросы к VictoriaLogs`.

### Основы запросов LogsQL

Самый простой запрос LogsQL — это просто **слово**, которое нужно найти в **сообщении лога** (поле `_msg`).

Например, следующий запрос найдёт все логи, содержащие слово `error`:

```logsql
error
```

Для выполнения запросов к VictoriaLogs рекомендуется использовать утилиту **`vlogscli`**.

Если искомое слово совпадает с ключевым словом LogsQL, его нужно заключить в кавычки (см. `документацию по строковым литералам`).

Пример запроса для поиска слова `and`:

```logsql
"and"
```

Можно заключать в кавычки любое слово — это допустимо:

```logsql
"error"
```

Также можно заключать в кавычки фразы из нескольких слов. Например, этот запрос найдёт сообщения логов с фразой `error: cannot find file`:

```logsql
"error: cannot find file"
```

Вышеуказанные запросы возвращают логи с любым **временем записи** (`_time`), т. е. могут включать записи за прошлый год наряду с недавно поступившими.

Обычно логи за прошлый год менее интересны, чем свежие. Поэтому рекомендуется добавлять к запросу **фильтр по времени** (`time filter`).

Пример: запрос возвращает логи со словом `error`, поступившие в VictoriaLogs за последние 5 минут:

```logsql
error AND _time:5m
```

Этот запрос состоит из двух **фильтров**, объединённых оператором `AND`:

- фильтр по слову `error`;
- фильтр по полю `_time`.

Оператор `AND` означает, что запись лога должна соответствовать **обоим** фильтрам, чтобы быть выбранной.

Типичный запрос LogsQL состоит из нескольких фильтров, соединённых оператором `AND`. Вводить и читать множество `AND` может быть утомительно, поэтому LogsQL позволяет опускать `AND`. Например, следующий запрос эквивалентен предыдущему:

```logsql
_time:5m error
```

### Сортировка и ограничение результатов

По умолчанию VictoriaLogs возвращает логи в произвольном порядке, так как сортировка большого объёма данных требует значительных ресурсов CPU и ОЗУ.

Если количество логов со словом `error` за последние 5 минут невелико (например, меньше нескольких миллионов), их можно отсортировать с помощью **конвейера `sort`** (`sort pipe`).

Пример: сортировка выбранных логов по полю `_time`:

```logsql
_time:5m error | sort by (_time)
```

Скорее всего, вам не потребуется анализировать более нескольких сотен логов. Поэтому можно ограничить количество возвращаемых записей с помощью **конвейера `limit`** (`limit pipe`).

Пример: возврат последних 10 логов со словом `error` за последние 5 минут:

```logsql
_time:5m error | sort by (_time) desc | limit 10
```

### Выбор полей

По умолчанию VictoriaLogs возвращает все **поля лога**. Если нужны только определённые поля, добавьте в конец запроса **конвейер `fields`** (`fields pipe`).

Пример: возврат только полей `_time`, `_stream` и `_msg`:

```logsql
error _time:5m | fields _time, _stream, _msg
```

### Исключение записей

Предположим, какое-то ошибочное приложение добавляет в каждый лог слово `buggy_app`. Чтобы исключить такие записи и сосредоточиться на реальных ошибках, используйте оператор `NOT`:

```logsql
_time:5m error NOT buggy_app
```

Оператор `NOT` часто используется, поэтому его можно заменить на `-` или `!` (символ `!` используется перед фильтрами `=` и `~`, например `!=` и `!~`).

Эквивалентный запрос:

```logsql
_time:5m error -buggy_app
```

Если другое ошибочное приложение добавляет в логи слово `foobar`, просто добавьте `-foobar`:

```logsql
_time:5m error -buggy_app -foobar
```

Этот запрос можно переписать более наглядно с оператором `OR` в скобках:

```logsql
_time:5m error -(buggy_app OR foobar)
```

**Важно:** скобки здесь обязательны, иначе запрос вернёт не те результаты.

Запрос `error -buggy_app OR foobar` интерпретируется как `(error AND NOT buggy_app) OR foobar`. Он вернёт логи со словом `foobar`, даже если они не содержат `error` или содержат `buggy_app`.

Поэтому рекомендуется явно использовать скобки, если вы не уверены в приоритетах операторов. Это также делает запросы понятнее и проще в поддержке.

### Запросы по полям

Предыдущие примеры предполагали, что слово `error` хранится в поле сообщения лога (`_msg`). Если оно хранится в другом поле, например `log.level`, добавьте префикс `log.level:`:

```logsql
_time:5m log.level:error -(buggy_app OR foobar)
```

Имя поля можно заключить в кавычки, если оно содержит специальные символы или ключевые слова, конфликтующие с синтаксисом LogsQL. Любое слово также можно заключить в кавычки (см. `документацию по строковым литералам`).

Эквивалентный запрос:

```logsql
"_time":"5m" "log.level":"error" -("buggy_app" OR "foobar")
```

Если идентификатор приложения (например, `buggy_app` и `foobar`) хранится в поле `app`, добавьте префикс `app:`:

```logsql
_time:5m log.level:error -(app:buggy_app OR app:foobar)
```

Запрос можно упростить, вынеся префикс `app:` за скобки:

```logsql
_time:5m log.level:error -app:(buggy_app OR foobar)
```

### Оптимизация запросов

Если поле `app` однозначно идентифицирует экземпляр приложения (т. е. для каждого уникального `app` работает один экземпляр), рекомендуется связать это поле с **полями потока логов** (`log stream fields`) при загрузке данных (`data ingestion`). Это обычно улучшает сжатие и производительность запросов при фильтрации по потокам с помощью фильтра `_stream` (`_stream filter`).

Если `app` связан с потоком логов, запрос можно переписать для повышения производительности:

```logsql
_time:5m log.level:error {app!~"buggy_app|foobar"}
```

Этот запрос пропускает сканирование сообщений логов от приложений `buggy_app` и `foobar`, проверяя только поля `log.level` и `_stream`. Это значительно снижает нагрузку на диск и CPU.

### Статистические функции

LogsQL предоставляет **функции для расчёта статистики** (`stats pipe`) по выбранным логам.

Пример: возврат количества логов со словом `error` за последние 5 минут:

```logsql
_time:5m error | stats count() logs_with_error
```

### Ключевые понятия

#### Слово (Word)

LogsQL разбивает все **поля лога** на слова, разделённые небуквенными символами (пробелы, скобки, знаки препинания и т. д.). Например, строка `foo: (bar,"тест")!` разбивается на слова `foo`, `bar` и `тест`. Слова могут содержать любые символы UTF‑8.

