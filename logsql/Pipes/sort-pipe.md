## Оператор `sort` (сортировка)

По умолчанию логи выбираются в произвольном порядке — это сделано для повышения производительности. Если требуется отсортировать логи, используйте оператор `<q> | sort by (поле1, ..., полеN)` — он отсортирует логи, возвращённые запросом `<q>`, по указанным полям с применением **естественного порядка сортировки** (*natural sorting*).

Например, следующий запрос вернёт логи за последние 5 минут, отсортированные сначала по полю `_stream`, а затем по `_time`:

```logsql
_time:5m | sort by (_stream, _time)
```

Чтобы отсортировать по полю в **обратном порядке**, добавьте `desc` после имени поля. Например, так сортируются логи по убыванию значения поля `request_duration_seconds`:

```logsql
_time:5m | sort by (request_duration_seconds desc)
```

Обратный порядок можно задать **глобально**, поместив `desc` после конструкции `by(...)`:

```logsql
_time:5m | sort by (foo, bar) desc
```

Ключевое слово `by` в операторе `sort` можно опустить. Следующий запрос эквивалентен предыдущему:

```logsql
_time:5m | sort (foo, bar) desc
```

Вместо `sort` можно использовать псевдоним `order` — результат будет тем же:

```logsql
_time:5m | order by (foo, bar) desc
```

Сортировка большого объёма логов может потреблять много CPU и памяти. Часто достаточно вернуть первые `N` записей с наибольшими или наименьшими значениями. Для этого добавьте `limit N` в конец оператора `sort`. Такой запрос потребляет меньше памяти, так как хранит в памяти только `N` записей.

Например, следующий запрос вернёт **топ‑10** логов с наибольшими значениями поля `request_duration` за последний час:

```logsql
_time:1h | sort by (request_duration desc) limit 10
```

Этот запрос эквивалентен следующему, где используется оператор `last`:

```logsql
_time:1h | last 10 by (request_duration)
```

Если нужно **пропустить** первые `N` отсортированных записей, добавьте `offset N` к оператору `sort`. Например, следующий запрос пропустит первые 10 логов с наибольшим `request_duration`, а затем вернёт следующие 20 отсортированных логов за последние 5 минут:

```logsql
_time:1h | sort by (request_duration desc) offset 10 limit 20
```

Можно сортировать логи и применять `limit` **отдельно для каждой группы** логов с одинаковым набором полей, перечислив эти поля в `partition by (...)`.

Например, следующий запрос вернёт до 3 логов с наибольшим `request_duration` для каждого хоста за последний час:

```logsql
_time:1h | sort by (request_duration desc) partition by (host) limit 3
```

Можно вернуть **ранг** (номер по порядку сортировки) для каждого отсортированного лога, добавив `rank as <имяПоля>` в конец оператора `| sort ...`.

Например, следующий запрос сохранит ранг для логов, отсортированных по `_time`, в поле `position`:

```logsql
_time:5m | sort by (_time) rank as position
```

**Важно:** сортировка большого объёма логов может быть медленной и потреблять много дополнительной памяти. Рекомендуется ограничивать количество логов **до сортировки** следующими способами:

- Добавить `limit N` в конец оператора `sort ...`.
- Уменьшить выбранный временной диапазон с помощью **фильтра по времени**.
- Использовать более конкретные **фильтры**, чтобы выбирать меньше логов.
- Ограничить количество выбираемых **полей** с помощью оператора `fields`.

